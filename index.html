<!doctype html>
<html lang="hu">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1, viewport-fit=cover" />
  <title>AI + CV quadtych — mobile-first</title>

  <!-- p5 -->
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/p5.min.js"></script>

  <!-- ml5 -->
  <script src="https://cdn.jsdelivr.net/npm/ml5@0.12.2/dist/ml5.min.js"></script>

  <!-- OpenCV.js -->
  <script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>

  <style>
    :root { color-scheme: dark; }
    html, body { margin:0; padding:0; background:#0b0b0b; color:#ddd; font-family: system-ui, -apple-system, Segoe UI, Roboto; }

    #topbar{
      position: sticky; top: 0; z-index: 10;
      background: rgba(0,0,0,0.72);
      backdrop-filter: blur(10px);
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    #buttons button{
      margin-right:8px; margin-bottom:8px;
      padding:10px 12px; border-radius:12px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color:#fff; font-size:14px;
    }
    #status{ opacity:0.92; font-size: 13px; line-height: 1.35; margin-top:6px; }

    #wrap{ max-width: 1100px; margin: 0 auto; padding: 10px 12px 24px; }

    canvas{ width:100% !important; height:auto !important; display:block; border-radius:16px; }

    #machineLog{
      width:100%;
      min-height: 240px;
      height: 34vh;
      margin-top: 12px;
      padding: 12px 12px;
      box-sizing:border-box;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.10);
      background:#070707; color:#d8d8d8;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size:12px; line-height:1.35;
      white-space:pre; overflow:auto;
    }
    #machineLog::selection { background: rgba(255,255,255,0.18); }
  </style>
</head>

<body>
  <div id="topbar">
    <div id="buttons"></div>
    <div id="status">Tap to enable camera (iPhone: Safari-ban)</div>
  </div>

  <div id="wrap">
    <textarea id="machineLog" spellcheck="false"></textarea>
  </div>

<script>
/* ================== Mobil-first layout ================== */
let P = 520;
let CANVAS_W = 520;
let CANVAS_H = 520;
let isMobileLayout = true;

function computeLayout() {
  const vw = Math.min(window.innerWidth, 1100);
  P = Math.floor(Math.min(vw - 24, 720));
  P = Math.max(320, P);

  isMobileLayout = (window.innerWidth < 900);

  if (isMobileLayout) {
    CANVAS_W = P;
    CANVAS_H = P * 4;   // 4 panel egymás alatt
  } else {
    CANVAS_W = P * 2;
    CANVAS_H = P * 2;   // 2x2 quad
  }
}

function panelRect(n) {
  if (isMobileLayout) return { x: 0, y: (n-1)*P, w: P, h: P };
  if (n === 1) return { x: 0,   y: 0,   w: P, h: P };
  if (n === 2) return { x: P,   y: 0,   w: P, h: P };
  if (n === 3) return { x: 0,   y: P,   w: P, h: P };
  return           { x: P,   y: P,   w: P, h: P };
}

/* ================== KONFIG (kamera) ================== */
const camW = 640, camH = 480;

/* luminancia mező */
const gridCols = 72, gridRows = 54;

/* ================== ÁLLAPOT: kamera ================== */
let cam = null, offG = null;
let camInit = null;

/* iPhone tap-to-start kamera */
async function startIPhoneCamera({ useBackCamera = true } = {}) {
  if (!navigator.mediaDevices?.getUserMedia) {
    alert("Nincs getUserMedia támogatás ebben a böngészőben.");
    return null;
  }

  const constraints = {
    audio: false,
    video: {
      width: { ideal: camW },
      height: { ideal: camH },
      facingMode: useBackCamera ? { ideal: "environment" } : "user"
    }
  };

  const stream = await navigator.mediaDevices.getUserMedia(constraints);

  // p5 videó elem (iOS stabilabb)
  const v = createVideo([]);
  v.elt.srcObject = stream;
  v.elt.setAttribute("playsinline", "");
  v.elt.setAttribute("webkit-playsinline", "");
  v.elt.muted = true;
  v.elt.autoplay = true;

  v.size(camW, camH);
  v.hide();

  return { p5video: v, stream };
}

async function ensureCameraStarted() {
  if (camInit) return camInit;

  camInit = startIPhoneCamera({ useBackCamera: true })
    .then(res => {
      if (!res) return null;
      cam = res.p5video;
      return cam.elt.play().catch(() => {});
    })
    .catch(err => {
      console.error(err);
      alert("Kamera hiba / engedély megtagadva.\n(iPhone: Safari + HTTPS + kamera engedély)");
      camInit = null;
      return null;
    });

  return camInit;
}

function touchStarted() { ensureCameraStarted(); return false; }
function mousePressed() { ensureCameraStarted(); }

/* ================== VIDEO REC (R: start/stop) ==================
   iOS-en sokszor nincs MediaRecorder támogatás → desktopon ok.
*/
let rec = {
  active: false,
  recorder: null,
  chunks: [],
  stream: null,
  startedAt: 0
};

/* ================== AI: COCO-SSD ================== */
let detector = null;
let detectorReady = false;
let detections = [];
let lastDetectAt = 0;
let detectIntervalMs = 520; // mobilon ritkábban

/* ================== CV: OpenCV ================== */
let cvReady = false;
let orb = null;
let keypoints = [];
let edgePts = [];
let edgeDensity = 0;

/* ================== “mérés”: luminancia mező ================== */
let lumField = [];
let lumFieldSm = [];
let avgBrightness = 0;

/* ================== PANEL 2: line-memory ================== */
let lineMemG = null;

let P2_FADE = 14;
let P2_STROKES_PER_FRAME = 140;  // mobilon kevesebb
let P2_STEPS_MIN = 12;
let P2_STEPS_MAX = 38;
let P2_STEP_SIZE = 3.10;
let P2_BREAK_PROB = 0.18;
let P2_BASE_W = 0.55;

let lumOpt = [];
let lumOptSm = [];
let targetLum = 0.62;

/* ================== PANEL 3: particle dataflow ================== */
let particles = [];
let MAX_PARTICLES = 950; // mobilon kisebb

class Particle {
  constructor(x, y, vx, vy, life, w0) {
    this.x = x; this.y = y;
    this.vx = vx; this.vy = vy;
    this.life = life;
    this.age = 0;
    this.px = x; this.py = y;
    this.w0 = w0;
  }
  step(flowFx, flowFy) {
    this.px = this.x; this.py = this.y;
    this.vx = this.vx * 0.92 + flowFx * 0.55;
    this.vy = this.vy * 0.92 + flowFy * 0.55;
    this.x += this.vx;
    this.y += this.vy;
    this.age++;
    return (this.age < this.life);
  }
}

/* ================== PANEL 4: copyable log ================== */
const logEl = document.getElementById('machineLog');
let logLines = [];
const LOG_MAX = 240;
let lastLogAt = 0;
let logIntervalMs = 260;

let fpsSmoothed = 0;

/* UI */
const statusEl = document.getElementById('status');

function saveImageIOS(getImgFn) {
  try {
    const img = getImgFn();
    const dataUrl = img.canvas.toDataURL('image/png');

    const w = window.open('', '_blank');
    if (!w) {
      alert("Popup blokkolva. Safari: engedélyezd a pop-upot.");
      return;
    }
    w.document.write(`
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <title>Save image</title>
      <style>body{margin:0;background:#000;display:flex;align-items:center;justify-content:center}</style>
      <img src="${dataUrl}" style="max-width:100%;height:auto" />
      <p style="position:fixed;bottom:10px;left:10px;color:#fff;font-family:system-ui">
        iPhone: hosszan nyomd a képet → “Save to Photos”
      </p>
    `);
    w.document.close();
  } catch (e) {
    console.error(e);
    alert("Mentés hiba (nézd meg a konzolt).");
  }
}

function addButtons() {
  const box = document.getElementById('buttons');
  box.innerHTML = '';

  const mk = (label, fn) => {
    const b = document.createElement('button');
    b.textContent = label;
    b.onclick = fn;
    box.appendChild(b);
  };

  mk('START CAM', () => ensureCameraStarted());

  mk('SAVE FULL', () => saveImageIOS(() => get(0, 0, CANVAS_W, CANVAS_H)));
  mk('SAVE P1', () => { const r=panelRect(1); saveImageIOS(() => get(r.x, r.y, r.w, r.h)); });
  mk('SAVE P2', () => { const r=panelRect(2); saveImageIOS(() => get(r.x, r.y, r.w, r.h)); });
  mk('SAVE P3', () => { const r=panelRect(3); saveImageIOS(() => get(r.x, r.y, r.w, r.h)); });
  mk('SAVE P4', () => { const r=panelRect(4); saveImageIOS(() => get(r.x, r.y, r.w, r.h)); });
}

/* ================== SETUP ================== */
function setup() {
  computeLayout();
  const c = createCanvas(CANVAS_W, CANVAS_H);
  c.parent('wrap');
  pixelDensity(1);
  textFont('monospace');

  addButtons();

  offG = createGraphics(camW, camH);
  offG.pixelDensity(1);

  // mobil vs desktop finomhangolás
  if (isMobileLayout) {
    detectIntervalMs = 560;
    P2_STROKES_PER_FRAME = 120;
    MAX_PARTICLES = 850;
  } else {
    detectIntervalMs = 260;
    P2_STROKES_PER_FRAME = 220;
    MAX_PARTICLES = 2200;
  }

  // COCO-SSD
  detector = ml5.objectDetector('cocossd', { flipHorizontal: true }, () => {
    detectorReady = true;
    console.log("COCO-SSD ready");
  });

  // OpenCV init
  const waitCV = setInterval(() => {
    if (window.cv && cv.Mat) {
      clearInterval(waitCV);
      cvReady = true;
      try { orb = new cv.ORB(); }
      catch (e) { try { orb = cv.ORB_create(); } catch(e2) { orb = null; } }
      console.log("OpenCV ready. ORB:", !!orb);
    }
  }, 60);

  // lum mezők init
  for (let r = 0; r < gridRows; r++) {
    lumField[r] = new Array(gridCols).fill(0);
    lumFieldSm[r] = new Array(gridCols).fill(0);
    lumOpt[r] = new Array(gridCols).fill(0);
    lumOptSm[r] = new Array(gridCols).fill(0);
  }

  // panel2 memória (P x P!)
  lineMemG = createGraphics(P, P);
  lineMemG.pixelDensity(1);
  lineMemG.background(248);
  lineMemG.stroke(0);
  lineMemG.noFill();

  // log init
  logEl.value =
`MACHINE STREAM / COPYABLE
panel4 := feature-tokens derived from the same camera frame as panels 1–3
---------------------------------------------------------------\n`;
  logEl.scrollTop = logEl.scrollHeight;
}

function windowResized() {
  const oldP = P;
  computeLayout();
  resizeCanvas(CANVAS_W, CANVAS_H);

  // ha P változott, újra kell a lineMemG (különben elcsúszik)
  if (P !== oldP) {
    const old = lineMemG;
    lineMemG = createGraphics(P, P);
    lineMemG.pixelDensity(1);
    lineMemG.background(248);
    lineMemG.stroke(0);
    lineMemG.noFill();
    if (old) { /* nem kötelező átmásolni */ }
  }

  addButtons();
}

/* ================== DRAW ================== */
function draw() {
  fpsSmoothed = lerp(fpsSmoothed, frameRate(), 0.12);

  // ha nincs kamera, csak üzenet
  if (!cam || !cam.elt || cam.elt.readyState < 2) {
    background(10);
    fill(255);
    textSize(16);
    text("Tap to enable camera", 14, 34);
    textSize(12);
    text("iPhone: Safari-ban nyisd meg + engedélyezd a kamerát.", 14, 54);
    statusEl.textContent = `Kamera: WAIT • AI:${detectorReady?"OK":"WAIT"} CV:${cvReady?"OK":"WAIT"} • FPS~${fpsSmoothed.toFixed(1)}`;
    return;
  }

  statusEl.textContent = `Kamera: OK • AI:${detectorReady?"OK":"WAIT"} CV:${cvReady?"OK":"WAIT"} • FPS~${fpsSmoothed.toFixed(1)}`;

  // camera -> offscreen + flip
  offG.push();
  offG.translate(camW, 0);
  offG.scale(-1, 1);
  offG.image(cam, 0, 0, camW, camH);
  offG.pop();

  computeBrightnessAndField(offG);
  computeOptimalLuminanceField();

  if (cvReady) {
    try { runOpenCV(offG); } catch(e) {}
  }

  // COCO detect
  const now = millis();
  if (detectorReady && now - lastDetectAt > detectIntervalMs) {
    lastDetectAt = now;
    detector.detect(offG.elt, (err, results) => {
      if (!err && results) detections = results;
    });
  }

  // panelek helye
  const r1 = panelRect(1);
  const r2 = panelRect(2);
  const r3 = panelRect(3);
  const r4 = panelRect(4);

  background(10);

  drawPanel1(r1.x, r1.y, r1.w, r1.h);
  drawPanel2(r2.x, r2.y, r2.w, r2.h);
  drawPanel3(r3.x, r3.y, r3.w, r3.h);
  drawPanel4BG(r4.x, r4.y, r4.w, r4.h);
  drawPanel4TextToCanvas(r4.x, r4.y, r4.w, r4.h);

  // machine log update
  if (now - lastLogAt > logIntervalMs) {
    lastLogAt = now;
    appendMachineLogLine();
    flushMachineLog();
  }
}

/* ================== PANEL 1: camera + overlay ================== */
function drawPanel1(x, y, w, h) {
  noStroke(); fill(0); rect(x, y, w, h);

  drawImageCover(offG, x, y, w, h);
  drawScanOverlay(x, y, w, h);
  drawKeypointsOverlaySoft(x, y, w, h);
  drawEdgesDotsBlue(x, y, w, h);
  drawDetectionsOverlayWhite(x, y, w, h);

  // info bar
  noStroke();
  fill(0, 190);
  rect(x + 12, y + h - 80, w - 24, 66, 12);
  fill(245);
  textSize(12);

  const sum = summarizeDetections(detections, 4);
  const cvS = cvReady ? "CV:OK" : "CV:WAIT";
  const aiS = detectorReady ? "AI:OK" : "AI:WAIT";
  text(`${aiS} ${cvS}  COCO: ${sum || "—"}`, x + 22, y + h - 52);
  text(`lumμ=${avgBrightness.toFixed(3)}  edgeρ=${edgeDensity.toFixed(3)}  kp=${keypoints.length}  obj=${detections.length}`, x + 22, y + h - 32);
}

/* ================== PANEL 2: line-memory ================== */
function drawPanel2(x, y, w, h) {
  noStroke(); fill(248); rect(x, y, w, h);

  updateLineMemoryPanel2();

  push();
  translate(x, y);
  image(lineMemG, 0, 0, w, h);

  noFill(); stroke(0, 150); strokeWeight(1);
  rect(12, 12, w - 24, h - 24);

  noStroke(); fill(0, 130);
  textSize(12);
  text(`reality-correction → optimal-luminance trace`, 20, 32);
  pop();
}

/* ================== PANEL 3: particle dataflow ================== */
function drawPanel3(x, y, w, h) {
  noStroke(); fill(0); rect(x, y, w, h);

  push();
  translate(x, y);

  drawSoftGrid(w, h);
  seedParticles(w, h);

  let alive = [];
  const N = particles.length;

  const cell = 26;
  const cols = ceil(w / cell), rows = ceil(h / cell);
  const bins = new Array(cols * rows);
  for (let i = 0; i < bins.length; i++) bins[i] = [];

  for (let i = 0; i < N; i++) {
    const p = particles[i];

    const camX = map(p.x, 0, w, 0, camW);
    const camY = map(p.y, 0, h, 0, camH);
    const b = sampleFieldAtSm(camX, camY);

    const n = noise(p.x * 0.0017, p.y * 0.0017, frameCount * 0.0022);
    const ang = n * TWO_PI * 2.0;

    const strength = map(1 - b, 0, 1, 0.03, 0.42);
    const fx = cos(ang) * strength;
    const fy = sin(ang) * strength;

    const ok = p.step(fx, fy);

    if (p.x < 0) p.x += w; if (p.x > w) p.x -= w;
    if (p.y < 0) p.y += h; if (p.y > h) p.y -= h;

    if (ok) {
      const a = map(p.age, 0, p.life, 110, 8);
      const sw = 0.65 + p.w0 * 1.25;
      strokeWeight(sw);
      stroke(255, a);
      line(p.px, p.py, p.x, p.y);

      const cx = constrain(floor(p.x / cell), 0, cols - 1);
      const cy = constrain(floor(p.y / cell), 0, rows - 1);
      bins[cy * cols + cx].push(p);

      alive.push(p);
    }
  }
  particles = alive;

  for (let by = 0; by < rows; by++) {
    for (let bx = 0; bx < cols; bx++) {
      const bin = bins[by * cols + bx];
      if (bin.length < 2) continue;

      const lim = min(bin.length, 16);
      for (let i = 0; i < lim; i++) {
        const a = bin[i];
        for (let j = i + 1; j < lim; j++) {
          const b = bin[j];
          const dx = a.x - b.x, dy = a.y - b.y;
          const d2 = dx*dx + dy*dy;

          const camX = map((a.x+b.x)*0.5, 0, w, 0, camW);
          const camY = map((a.y+b.y)*0.5, 0, h, 0, camH);
          const lum = sampleFieldAtSm(camX, camY);
          const R = lerp(26, 54, 1 - lum);
          const R2 = R*R;

          if (d2 < R2 && random() < 0.36) {
            const alpha = map(d2, 0, R2, 110, 0);
            stroke(255, alpha);
            strokeWeight(0.75 + 0.6 * (a.w0 + b.w0) * 0.5);
            line(a.x, a.y, b.x, b.y);
          }
        }
      }
    }
  }

  noStroke();
  fill(255, 140);
  textSize(12);
  text(`obj:${detections.length}  kp:${keypoints.length}  edgeρ:${edgeDensity.toFixed(3)}  particles:${particles.length}`, 14, 22);
  pop();
}

/* ================== PANEL 4 BG + text on canvas ================== */
function drawPanel4BG(x, y, w, h) {
  noStroke(); fill(7); rect(x, y, w, h);
  push();
  translate(x, y);
  noFill(); stroke(255, 18); strokeWeight(1);
  rect(10, 10, w - 20, h - 20);
  noStroke(); fill(255, 70);
  textSize(12);
  text(`machine-log (copyable textarea below)`, 16, 26);
  pop();
}

function drawPanel4TextToCanvas(x, y, w, h) {
  push();
  translate(x, y);

  const pad = 18;
  const innerW = w - pad*2;
  const innerH = h - pad*2;

  const header =
`MACHINE STREAM / CANVAS PREVIEW
---------------------------------------------------------------`;

  const lines = header.split("\n").concat(logLines);

  textFont('monospace');
  textSize(12);
  noStroke();
  fill(216);

  const lineH = 12 * 1.35;
  const maxLines = floor(innerH / lineH);
  const start = max(0, lines.length - maxLines);

  let yy = pad + 10;
  for (let i = start; i < lines.length; i++) {
    let out = lines[i];
    while (textWidth(out) > innerW && out.length > 4) out = out.slice(0, -4) + "…";
    text(out, pad, yy);
    yy += lineH;
    if (yy > pad + innerH) break;
  }
  pop();
}

/* ================== PANEL 2 motor ================== */
function updateLineMemoryPanel2() {
  if (!lineMemG) return;

  if (P2_FADE > 0) {
    lineMemG.noStroke();
    lineMemG.fill(248, P2_FADE);
    lineMemG.rect(0, 0, P, P);
  }

  for (let s = 0; s < P2_STROKES_PER_FRAME; s++) {
    const seed = pickSeedForPanel2();
    if (!seed) continue;
    traceContourLogic(seed.x, seed.y, seed.bias);
  }
}

function pickSeedForPanel2() {
  if (edgePts && edgePts.length > 0 && random() < 0.64) {
    const p = edgePts[floor(random(edgePts.length))];
    return { x: map(p.x, 0, camW, 0, P), y: map(p.y, 0, camH, 0, P), bias: 1.0 };
  }
  if (keypoints && keypoints.length > 0 && random() < 0.82) {
    const k = keypoints[floor(random(keypoints.length))];
    return { x: map(k.x, 0, camW, 0, P), y: map(k.y, 0, camH, 0, P), bias: 0.85 };
  }
  if (detections && detections.length > 0) {
    const d = detections[floor(random(detections.length))];
    const cx = d.x + d.width * 0.5;
    const cy = d.y + d.height * 0.5;
    const conf = constrain(d.confidence ?? d.score ?? 0.6, 0, 1);
    return { x: map(cx, 0, camW, 0, P), y: map(cy, 0, camH, 0, P), bias: 0.65 + conf*0.55 };
  }
  return null;
}

function sampleOptAtSm(camX, camY) {
  return sampleFieldGeneric(lumOptSm, camX, camY);
}

function gradAtPanel(px, py) {
  let cx = map(px, 0, P, 0, camW - 1);
  let cy = map(py, 0, P, 0, camH - 1);
  cx = constrain(cx, 0, camW - 1);
  cy = constrain(cy, 0, camH - 1);

  const eps = 6;
  const l = sampleOptAtSm(cx - eps, cy);
  const r = sampleOptAtSm(cx + eps, cy);
  const u = sampleOptAtSm(cx, cy - eps);
  const d = sampleOptAtSm(cx, cy + eps);

  return { gx: (r - l), gy: (d - u), lum: sampleOptAtSm(cx, cy) };
}

function traceContourLogic(x0, y0, bias = 1.0) {
  let x = constrain(x0, 2, P - 3);
  let y = constrain(y0, 2, P - 3);

  const g0 = gradAtPanel(x, y);
  const gm = Math.hypot(g0.gx, g0.gy);
  if (gm < 0.004) return;

  const strength = constrain(gm * 60 * bias, 0, 1);
  const steps = floor(lerp(P2_STEPS_MIN, P2_STEPS_MAX, strength));

  const w = P2_BASE_W + strength * 0.25;
  const a = lerp(18, 85, strength);
  lineMemG.stroke(0, a);
  lineMemG.strokeWeight(w);

  let tx = -g0.gy;
  let ty =  g0.gx;
  let tlen = Math.hypot(tx, ty) || 1;
  tx /= tlen; ty /= tlen;
  if (random() < 0.5) { tx *= -1; ty *= -1; }

  let px = x, py = y;

  for (let i = 0; i < steps; i++) {
    const breakHere = (random() < (P2_BREAK_PROB + (1 - strength) * 0.12));
    if (!breakHere) lineMemG.line(px, py, x, y);

    const g = gradAtPanel(x, y);
    const mag = Math.hypot(g.gx, g.gy);
    if (mag < 0.003) break;

    let ntx = -g.gy;
    let nty =  g.gx;
    let nlen = Math.hypot(ntx, nty) || 1;
    ntx /= nlen; nty /= nlen;

    tx = tx * 0.78 + ntx * 0.22;
    ty = ty * 0.78 + nty * 0.22;
    const tl = Math.hypot(tx, ty) || 1;
    tx /= tl; ty /= tl;

    const step = P2_STEP_SIZE * lerp(1.15, 0.85, strength);

    px = x; py = y;
    x += tx * step;
    y += ty * step;

    if (x < 2 || x > P - 3 || y < 2 || y > P - 3) break;
  }
}

/* ================== LUMINANCIA MEZŐ ================== */
function computeBrightnessAndField(gfx) {
  gfx.loadPixels();
  let sum = 0;

  for (let r = 0; r < gridRows; r++) {
    for (let c = 0; c < gridCols; c++) {
      const cx = floor((c + 0.5) * camW / gridCols);
      const cy = floor((r + 0.5) * camH / gridRows);

      let local = 0, cnt = 0;
      for (let oy = -2; oy <= 2; oy += 2) {
        for (let ox = -2; ox <= 2; ox += 2) {
          const x = constrain(cx + ox, 0, camW - 1);
          const y = constrain(cy + oy, 0, camH - 1);
          const idx = 4 * (y * camW + x);
          const R = gfx.pixels[idx], G = gfx.pixels[idx+1], B = gfx.pixels[idx+2];
          const L = (0.2126*R + 0.7152*G + 0.0722*B) / 255;
          local += L; cnt++;
        }
      }
      local /= max(1, cnt);
      lumField[r][c] = local;
      lumFieldSm[r][c] = lerp(lumFieldSm[r][c], local, 0.22);
      sum += local;
    }
  }
  avgBrightness = sum / (gridCols * gridRows);
}

/* ================== “AI” optimal luminance mező ================== */
function computeOptimalLuminanceField() {
  const globalErr = (targetLum - avgBrightness);
  const gain = constrain(0.75 + Math.abs(globalErr) * 1.2, 0.75, 1.35);

  const hasObj = (detections && detections.length > 0);
  const objBoost = hasObj ? 0.08 : 0.0;

  for (let r = 0; r < gridRows; r++) {
    for (let c = 0; c < gridCols; c++) {
      const L = lumFieldSm[r][c];

      let corrected = pow(L, 0.85) * gain + globalErr * 0.55;

      const l = lumFieldSm[r][max(0, c-1)];
      const rr = lumFieldSm[r][min(gridCols-1, c+1)];
      const u = lumFieldSm[max(0, r-1)][c];
      const d = lumFieldSm[min(gridRows-1, r+1)][c];
      const localEdge = Math.abs(rr - l) + Math.abs(d - u);

      corrected += localEdge * (0.22 + objBoost);
      corrected = constrain(corrected, 0, 1);

      lumOpt[r][c] = corrected;
      lumOptSm[r][c] = lerp(lumOptSm[r][c], corrected, 0.18);
    }
  }
}

/* ===== sampler ===== */
function sampleFieldAtSm(camX, camY) {
  return sampleFieldGeneric(lumFieldSm, camX, camY);
}
function sampleFieldGeneric(field, camX, camY) {
  if (!field || field.length === 0) return 0.0;
  camX = constrain(camX, 0, camW - 1);
  camY = constrain(camY, 0, camH - 1);

  const fx = (camX / (camW - 1)) * (gridCols - 1);
  const fy = (camY / (camH - 1)) * (gridRows - 1);

  const x0 = constrain(floor(fx), 0, gridCols - 1);
  const y0 = constrain(floor(fy), 0, gridRows - 1);
  const x1 = min(x0 + 1, gridCols - 1);
  const y1 = min(y0 + 1, gridRows - 1);

  const tx = fx - x0;
  const ty = fy - y0;

  const a = field[y0][x0];
  const b = field[y0][x1];
  const c = field[y1][x0];
  const d = field[y1][x1];

  return lerp(lerp(a, b, tx), lerp(c, d, tx), ty);
}

/* ================== OpenCV ================== */
function runOpenCV(gfx) {
  const src = cv.imread(gfx.elt);
  const gray = new cv.Mat();
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

  const edges = new cv.Mat();
  cv.Canny(gray, edges, 50, 140);

  edgePts = [];
  const stride = 4;
  let edgeCount = 0;
  const total = (camW/stride)*(camH/stride);

  for (let y = 0; y < edges.rows; y += stride) {
    for (let x = 0; x < edges.cols; x += stride) {
      const v = edges.ucharPtr(y, x)[0];
      if (v > 0) { edgePts.push({ x, y }); edgeCount++; }
    }
  }
  edgeDensity = constrain(edgeCount / max(1,total), 0, 1);

  keypoints = [];
  if (orb) {
    const kp = new cv.KeyPointVector();
    const desc = new cv.Mat();
    try {
      orb.detect(gray, kp);
      orb.compute(gray, kp, desc);
      const count = kp.size();
      const lim = Math.min(count, 520);
      for (let i = 0; i < lim; i++) {
        const k = kp.get(i);
        keypoints.push({ x: k.pt.x, y: k.pt.y, response: k.response });
      }
    } catch (e) {}
    kp.delete(); desc.delete();
  }

  src.delete(); gray.delete(); edges.delete();
}

/* ================== Panel1 overlay pieces ================== */
function drawScanOverlay(x,y,w,h){
  stroke(255, 14);
  strokeWeight(1);
  for (let yy=y; yy<y+h; yy+=6) line(x, yy, x+w, yy);

  const cellW = w/gridCols, cellH = h/gridRows;
  noStroke();
  for (let r=0;r<gridRows;r++){
    for (let c=0;c<gridCols;c++){
      const b = lumFieldSm[r][c];
      const a = map(1-b, 0, 1, 0, 110);
      fill(0, a);
      rect(x+c*cellW, y+r*cellH, cellW, cellH);
    }
  }
}

function drawKeypointsOverlaySoft(x,y,w,h){
  if (!keypoints || keypoints.length===0) return;
  const lim = min(keypoints.length, 220);
  for (let i=0;i<lim;i++){
    const k = keypoints[i];
    const px = map(k.x,0,camW,x,x+w);
    const py = map(k.y,0,camH,y,y+h);
    const rr = map(constrain(k.response,0,0.06), 0,0.06, 2,9);
    noFill();
    stroke(255, 210, 120, 110);
    strokeWeight(1);
    ellipse(px,py, rr, rr);
  }
}

function drawEdgesDotsBlue(x,y,w,h){
  if (!edgePts || edgePts.length===0) return;
  const n = min(edgePts.length, 2400);
  stroke(0,0,250, 150);
  strokeWeight(1);
  for (let i=0;i<n;i+=2){
    const p = edgePts[i];
    const px = map(p.x,0,camW,x,x+w);
    const py = map(p.y,0,camH,y,y+h);
    point(px,py);
  }
}

function drawDetectionsOverlayWhite(x,y,w,h){
  if (!detections || detections.length===0) return;
  for (let i=0;i<detections.length;i++){
    const d = detections[i];
    const conf = constrain(d.confidence ?? d.score ?? 0, 0, 1);

    const bx = map(d.x,0,camW,x,x+w);
    const by = map(d.y,0,camH,y,y+h);
    const bw = map(d.width,0,camW,0,w);
    const bh = map(d.height,0,camH,0,h);

    const cx = bx + bw*0.5;
    const cy = by + bh*0.5;

    stroke(255, 240);
    strokeWeight(2.2);
    noFill();
    rect(bx,by,bw,bh);

    stroke(255, 140);
    strokeWeight(1.1);
    line(cx-18, cy, cx+18, cy);
    line(cx, cy-18, cx, cy+18);

    noStroke();
    fill(0, 185);
    rect(bx, by-22, min(340, textWidth(d.label)+92), 18, 6);

    fill(255);
    textSize(12);
    const cPct = Math.round(conf*100);
    text(`#${i} ${d.label} ${cPct}%`, bx+8, by-9);

    fill(255, 60);
    rect(bx, by+bh+6, bw, 4, 2);
    fill(255, 190);
    rect(bx, by+bh+6, bw*conf, 4, 2);
  }
}

/* ================== Panel3 helpers ================== */
function drawSoftGrid(w,h){
  stroke(255, 10);
  strokeWeight(1);
  const step = 48;
  for (let x=0; x<=w; x+=step) line(x, 0, x, h);
  for (let y=0; y<=h; y+=step) line(0, y, w, y);

  stroke(255, 6);
  const step2 = 24;
  for (let x=0; x<=w; x+=step2) if (x%step!==0) line(x, 0, x, h);
  for (let y=0; y<=h; y+=step2) if (y%step!==0) line(0, y, w, y);
}

function seedParticles(w,h){
  const kN = min(keypoints.length, 200);
  for (let i=0;i<kN;i+=6){
    const k = keypoints[i];
    const px = map(k.x,0,camW,0,w);
    const py = map(k.y,0,camH,0,h);
    const w0 = constrain(map(k.response, 0, 0.06, 0.2, 1.4), 0.2, 1.4);
    spawn(px,py, 0.18, 0.18, 220 + floor(w0*240), w0);
  }

  for (const d of detections){
    const conf = constrain(d.confidence ?? d.score ?? 0.6, 0, 1);
    const cx = d.x + d.width*0.5;
    const cy = d.y + d.height*0.5;
    const px = map(cx,0,camW,0,w);
    const py = map(cy,0,camH,0,h);
    const w0 = 0.9 + conf*1.2;
    spawn(px,py, 0.50, 0.50, 360 + floor(conf*240), w0);
  }

  const eN = min(edgePts.length, 900);
  for (let i=0;i<eN;i+=14){
    const p = edgePts[i];
    const px = map(p.x,0,camW,0,w);
    const py = map(p.y,0,camH,0,h);
    const w0 = 0.35 + edgeDensity*0.6;
    spawn(px,py, 0.14, 0.14, 180 + floor(edgeDensity*220), w0);
  }

  if (particles.length > MAX_PARTICLES) {
    particles.splice(0, particles.length - MAX_PARTICLES);
  }
}

function spawn(x,y,vscale,jitter,life,w0){
  const vx = (random(-1,1)*vscale) + random(-jitter,jitter);
  const vy = (random(-1,1)*vscale) + random(-jitter,jitter);
  particles.push(new Particle(x,y,vx,vy,life,w0));
}

/* ================== Panel4 log ================== */
function appendMachineLogLine(){
  const sig = signatureFromLum(lumFieldSm);
  const detTok = compactDetTokens(detections, 3);

  let kpE = 0;
  for (let i=0;i<min(keypoints.length, 180);i++){
    kpE += constrain(keypoints[i].response, 0, 0.08);
  }
  kpE = constrain(kpE / 3.0, 0, 1);

  const t = nf(millis()/1000, 0, 2);
  const line =
    `t=${t} Lμ=${avgBrightness.toFixed(3)} Eρ=${edgeDensity.toFixed(3)} ` +
    `KP=${toHex2(min(255,keypoints.length))} KE=${toHex2(floor(kpE*255))} ` +
    `OBJ=${toHex2(min(255,detections.length))} TOK=${detTok} SIG=${sig}`;

  logLines.push(line);
  if (logLines.length > LOG_MAX) logLines.shift();
}

function flushMachineLog(){
  const atBottom = (logEl.scrollTop + logEl.clientHeight >= logEl.scrollHeight - 18);

  const header =
`MACHINE STREAM / COPYABLE
panel4 := feature-tokens derived from the same camera frame as panels 1–3
---------------------------------------------------------------\n`;

  logEl.value = header + logLines.join("\n");
  if (atBottom) logEl.scrollTop = logEl.scrollHeight;
}

/* ================== Helpers: COCO tokens + signature ================== */
function summarizeDetections(dets, topN=4){
  if (!dets || dets.length===0) return "";
  const sorted = [...dets].sort((a,b)=>(b.confidence??b.score??0)-(a.confidence??a.score??0));
  return sorted.slice(0,topN).map(d=>{
    const c = Math.round(((d.confidence??d.score??0)*100));
    return `${d.label}(${c}%)`;
  }).join("  ");
}

function shortToken(label){
  const s = (label||"x").toLowerCase().replace(/[^a-z0-9]/g,"");
  return (s.slice(0,3) || "x");
}

function compactDetTokens(dets, topN=3){
  if (!dets || dets.length===0) return "∅";
  const sorted = [...dets].sort((a,b)=>(b.confidence??b.score??0)-(a.confidence??a.score??0));
  return sorted.slice(0,topN).map(d=>{
    const conf = Math.floor((d.confidence ?? d.score ?? 0) * 255);
    const cx = Math.floor(((d.x + d.width*0.5)/camW) * 255);
    const cy = Math.floor(((d.y + d.height*0.5)/camH) * 255);
    return `${shortToken(d.label)}${toHex2(conf)}${toHex2(cx)}${toHex2(cy)}`;
  }).join("|");
}

function toHex2(v){
  const h = (v & 255).toString(16);
  return h.length===1 ? "0"+h : h;
}

function signatureFromLum(field){
  let hash = 0x811c9dc5; // FNV-1a
  for (let r=0;r<gridRows;r+=2){
    for (let c=0;c<gridCols;c+=2){
      const q = ((field[r][c]*255)|0) & 255;
      hash ^= q;
      hash = (hash * 0x01000193) >>> 0;
    }
  }
  return ("00000000"+hash.toString(16)).slice(-8);
}

/* ================== Panel1: cover crop ================== */
function drawImageCover(img, x, y, w, h) {
  const srcW = img.width, srcH = img.height;
  const srcAR = srcW / srcH;
  const dstAR = w / h;

  let sx, sy, sw, sh;
  if (srcAR > dstAR) {
    sh = srcH;
    sw = sh * dstAR;
    sx = (srcW - sw) / 2;
    sy = 0;
  } else {
    sw = srcW;
    sh = sw / dstAR;
    sx = 0;
    sy = (srcH - sh) / 2;
  }
  image(img, x, y, w, h, sx, sy, sw, sh);
}

/* ================== Mentés billentyűkkel (desktop) ================== */
function keyPressed() {
  if (key === 's' || key === 'S') saveCanvas('quadtych_' + Date.now(), 'png');

  if (key === '1') { const r=panelRect(1); const img = get(r.x,r.y,r.w,r.h); img.save('panel1_' + Date.now(), 'png'); }
  if (key === '2') { const r=panelRect(2); const img = get(r.x,r.y,r.w,r.h); img.save('panel2_' + Date.now(), 'png'); }
  if (key === '3') { const r=panelRect(3); const img = get(r.x,r.y,r.w,r.h); img.save('panel3_' + Date.now(), 'png'); }

  if (key === 'r' || key === 'R') {
    if (!rec.active) startRecording();
    else stopRecording();
  }
}

/* ================== Recorder (desktop mostly) ================== */
function startRecording() {
  if (rec.active) return;

  const canvasEl = document.querySelector('#wrap canvas');
  if (!canvasEl) return;

  const fps = 30;
  rec.stream = canvasEl.captureStream(fps);

  let options = {};
  const preferred = ['video/webm;codecs=vp9','video/webm;codecs=vp8','video/webm'];
  for (const mt of preferred) {
    if (window.MediaRecorder && MediaRecorder.isTypeSupported(mt)) {
      options.mimeType = mt; break;
    }
  }

  if (!window.MediaRecorder) {
    alert("MediaRecorder nem támogatott ebben a böngészőben (iOS Safari gyakran).");
    return;
  }

  rec.chunks = [];
  rec.recorder = new MediaRecorder(rec.stream, options);

  rec.recorder.ondataavailable = (e) => {
    if (e.data && e.data.size > 0) rec.chunks.push(e.data);
  };

  rec.recorder.onstop = () => {
    const mime = rec.recorder.mimeType || 'video/webm';
    const blob = new Blob(rec.chunks, { type: mime });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = `quadtych_rec_${Date.now()}.webm`;
    document.body.appendChild(a);
    a.click();
    a.remove();

    setTimeout(() => URL.revokeObjectURL(url), 2000);

    rec.recorder = null;
    rec.stream = null;
    rec.chunks = [];
  };

  rec.recorder.start(250);
  rec.active = true;
}

function stopRecording() {
  if (!rec.active) return;
  rec.active = false;

  try {
    if (rec.recorder && rec.recorder.state !== 'inactive') rec.recorder.stop();
  } catch (e) {}
}
</script>
</body>
</html>
